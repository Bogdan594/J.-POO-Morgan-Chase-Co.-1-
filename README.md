#J. POO Morgan Chase & Co. 1
## The Project
This project simulates a bank and all the functionalities you find in a bank.
## Commands Package
This package was created specifically to execute the commands received in the input.

I start with the Command interface, which has an execute method. Based on this interface, I created specific classes for each command. These classes implement the interface and provide their own execute method.

I'll briefly explain what each class does.

AddAccountCommand: The constructor sets the list of users, the user's email for whom the account will be created, the type, currency, and timestamp. For "savings" accounts, it also sets the interestRate. The execute method finds the user and adds a new account with an IBAN generated by the Utils class.

AddFundsCommand: The constructor contains the list of users, the account's IBAN where the money will be deposited, and the amount. The execute method finds the account and, once found, adds the funds.

AddInterestCommand: The constructor contains the timestamp, account, bank, and an ArrayNode for the output. The execute method finds the account and checks if it's a "savings" type; if not, it signals an error. If it is a "savings" account, the interest is added.

ChangeInterestCommand: The constructor has the account, the new rate, timestamp, bank, and ArrayNode for the output. The execute method finds the account, checks if it's a "savings" type, and signals an error if it's not. If it is a "savings" account, the rate is changed and a new transaction is created.

CheckCardStatus: The constructor has the bank, card number, timestamp, and ArrayNode for the output. The execute method searches for the card; if it's not found, an error is displayed. If found, it checks if the account balance is less than the minimum balance. If it is, the card is frozen and a transaction is created.

CreateCardCommand: The constructor contains the list of users, the email of the user being searched for, the user's account, and a timestamp. It searches for the user and account; if found, a new card and a transaction are created.

CreateOneTimeCardCommand: This works exactly like CreateCardCommand, except it creates a one-time card.

DeleteAccountCommand: The constructor has the list of users, account, email, output, and timestamp. It searches for the account and deletes it as long as it exists and the balance is 0. In any other case, an error message is displayed.

DeleteCardCommand: The constructor has the list of users, email, card number, and timestamp. It searches for the card and, if found, deletes it from the associated account's card list.

PayOnlineCommand: The constructor has the list of users, card number, amount, currency, timestamp, email, output, and merchant. It searches for the user and account. If the account isn't found, an error message is displayed. Otherwise, it calculates the available balance (account balance - minimum balance). If the account's currency is the same as the payment's, it checks if the card is frozen. If so, a transaction signals this. If not, it checks if the available balance is greater than the amount. If it is, the amount is deducted from the account, and it checks if the card was a one-time card. If it was, it's replaced with a new one-time card. If there aren't enough funds, a transaction signals this. There is also a case where the account's currency does not match the transaction's. In this case, the amount is converted using the exchangeRates and the previous steps are applied.

PrintTransactionsCommand: The constructor has the email, timestamp, bank, and output. The execute method finds the user by email and displays their transactions.

PrintUsersCommand: The constructor has the list of users, output, and timestamp. The execute method displays the users.

ReportCommand: The constructor has the timestamps for the search range, the account being searched for, the bank, and output. It searches for the user and account. If the account doesn't exist, it signals an error. If both the user and account exist, it iterates through the account's transactions and checks if each one falls within the input timestamps and matches the input account. If so, the transaction is added to a list that will be displayed at the end.

SendMoneyCommand: The constructor has the list of users, the involved accounts, amount, exchangeRates, output, timestamp, and description. The execute method searches for the users and accounts (by both IBAN and alias). If they exist, it checks if the two accounts have the same currency. If not, the amount will be converted to the recipient's currency using a method from the Tools class. If the sender has enough money in their account, the balances of the two accounts are adjusted, and a special transaction is added for both users (I'll detail why it's special in the transactions section).

SetAliasCommand: The constructor has the email, account, alias, timestamp, and bank. The execute method finds the user and account and, if found, sets the alias.

SetMinimumBalanceCommand: The constructor has the list of users, account, and amount. The execute method finds the account and sets the amount as the minimum balance.

SpendingReportCommand: The constructor has the timestamps, account, bank, and output. The execute method finds the account and user. If the account isn't found or is a "savings" type, an error is displayed. If this check passes, the account's transactions are retrieved. For each transaction, it checks if its timestamp is within the two input dates and if it belongs to the given input account. Additionally, for each transaction, the merchant and corresponding amount are added to a list of merchants and sums (I have a class for this). Finally, the list is sorted and displayed.

SplitPaymentCommand: The constructor has the list of users, amount, currency, timestamp, bank, and exchangeRates. The execute method searches for the users and accounts. Subsequently, it checks whether each account has enough money. If not, the last account in the list that doesn't have enough money will be set as the "failer," and a transaction will be generated for each account. If every account has enough money, a different type of transaction will be generated for each account.

These were the command classes.

I also have the CommandFactory class. This class creates a new command based on the required type, provides all the necessary parameters, and returns it.

## Myclasses Package

This package contains the necessary classes used throughout the project.

Account: This is an abstract class that contains the fields needed for an account. It's inherited by the following two classes:

ClassicAccount: for a normal account.

SavingsAccount: for a savings-type account.

Card: This is an abstract class that contains the fields needed for a card. It's inherited by the following two classes:

ClassicCard: for a normal card.

OneTimeCard: for a card that will be used only once.

Bank: This class contains a list of users, one for exchangeRates, and one for merchants. The constructor is a copy constructor that takes the necessary fields from the input to initialize the bank.

Commerciant: Contains fields for ID, description, and a list of merchants.

ComerciantAndSum: This class was created specifically for the SpendingReportCommand. It's essentially a "pair" class that associates a merchant with the amount the user has spent.

ExchangeRates: Contains the necessary fields for a currency exchange.

User: Contains the name, email, a list of accounts, and a list of transactions. It also has two methods: addAccount and a copy method (from the input).

Tools: This class contains methods that I use in multiple classes and commands. I preferred to create this class to avoid overloading certain classes that were already large. For example, the calculateAmountExchange method is used in three classes that were already quite long. The search method calculates intermediate sums through exchangeRates until the source and target currencies are the same. If an exchange rate from A to B exists but we need one from B to A, the rate is calculated as 1/rate. The findAccountUsingIBAN and findUserUsingAccount methods find an account by IBAN and a user by an account, respectively, and return them.

## Transactions

This package contains classes for specific transactions that all extend the abstract Transaction class. In short, for each transaction type, the description and any other necessary parameters are set. The only special transaction is SendMoneyTransaction, where a descriptor is passed to the constructor. This descriptor refers to the person associated with the transaction (1 for the sender, 0 for the receiver). In this case, only the description is changed based on this descriptor.

## Main

I initialize the Stats class and the CommandFactory. For each command in the input, a new command is created using the factory and then executed. Finally, the Utils class is reset.

## Design Patterns
I used two design patterns:

Factory: for the commands.

Singleton: for the bank
